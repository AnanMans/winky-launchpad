'use client';

import React, { useEffect, useState } from 'react';
import { useParams } from 'next/navigation';
import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';
import {
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  VersionedTransaction,
} from '@solana/web3.js';
import ActivitySparkline from '@/components/ActivitySparkline';
import type { Coin } from '../../../lib/types';

export default function CoinPage() {
  // --- Routing / params ---
  const params = useParams<{ id: string }>();
  const id = decodeURIComponent(params.id);

  // --- Wallet / connection ---
  const { connection } = useConnection();
const { connected, publicKey, sendTransaction, signTransaction } = useWallet() as any;

  // --- State ---
  const [loading, setLoading] = useState(true);
  const [coin, setCoin] = useState<Coin | null>(null);
  const [buyBusy, setBuyBusy] = useState(false);
  const [sellBusy, setSellBusy] = useState(false);
  const [lastSig, setLastSig] = useState<string | null>(null);

  // --- Load coin ---
  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        const res = await fetch(`/api/coins/${encodeURIComponent(id)}`);
        if (!res.ok) throw new Error('Not found');
        const { coin } = await res.json();
        if (!cancelled) setCoin(coin);
      } catch {
        if (!cancelled) setCoin(null);
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();
    return () => { cancelled = true; };
  }, [id]);

  // --- Helpers ---
  function base64ToBytes(b64: string): Uint8Array {
    try {
      // Browser path
      return Uint8Array.from(atob(b64), (c) => c.charCodeAt(0));
    } catch {
      // Polyfill / Node-like path (only if Buffer exists)
      // @ts-ignore
      return typeof Buffer !== 'undefined' ? Buffer.from(b64, 'base64') : new Uint8Array();
    }
  }

  function decodeTx(b64: string): Transaction | VersionedTransaction {
    const bytes = base64ToBytes(b64);
    try {
      return Transaction.from(bytes);
    } catch {
      return VersionedTransaction.deserialize(bytes);
    }
  }

  // --- BUY: simple SOL transfer to treasury, then server mints to buyer ---
  async function buy(amount: number) {
    try {
      if (!connected || !publicKey) { alert('Connect wallet first'); return; }
      if (!coin?.id) { alert('Coin not loaded'); return; }
      setBuyBusy(true);

      const treasury = new PublicKey(
        process.env.NEXT_PUBLIC_TREASURY ||
        '3i5geKAQxtTZru59oYzmjhuZaVqLxxV8VqhxE5STBsdT'
      );

      const { blockhash, lastValidBlockHeight } =
        await connection.getLatestBlockhash('processed');

      const tx = new Transaction({
        feePayer: publicKey,
        recentBlockhash: blockhash,
      }).add(
        SystemProgram.transfer({
          fromPubkey: publicKey,
          toPubkey: treasury,
          lamports: Math.floor(amount * LAMPORTS_PER_SOL),
        })
      );

      const sig = await sendTransaction(tx, connection, { maxRetries: 3 });
      await connection.confirmTransaction(
        { signature: sig, blockhash, lastValidBlockHeight },
        'confirmed'
      );
      setLastSig(sig);

      // tell server to mint tokens to buyer (best effort)
      const res = await fetch(`/api/coins/${encodeURIComponent(coin.id)}/buy`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({
          buyer: publicKey.toBase58(),
          amountSol: amount,
          sig,
        }),
      });

      const data = await res.json().catch(() => ({} as any));
      if (!res.ok) throw new Error(data?.error || 'Mint failed');

      alert(`✅ Minted for ${amount} SOL\nMint tx: ${data.mintSig || '(n/a)'}`);
    } catch (e: any) {
      console.error(e);
      alert(`❌ Buy failed: ${e?.message || String(e)}`);
    } finally {
      setBuyBusy(false);
    }
  }

// --- SELL: server builds partial tx (token->treasury + SOL payout), you sign & send
async function sell(amount: number) {
  try {
    if (!connected || !publicKey) { alert('Connect wallet first'); return; }
    if (!coin?.id) { alert('Coin not loaded'); return; }
    setSellBusy(true);

    // 1) Ask server for partially-signed tx
    const res = await fetch(`/api/coins/${encodeURIComponent(coin.id)}/sell`, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        seller: publicKey.toBase58(),
        amountSol: amount,
      }),
    });

    const data = await res.json().catch(() => ({} as any));
    if (!res.ok) throw new Error(data?.error || 'Sell prepare failed');
    if (!data?.tx) throw new Error('Missing tx payload from server');

    // 2) Decode base64 → bytes
    const bytes =
      (() => { try { return Uint8Array.from(atob(data.tx), c => c.charCodeAt(0)); } catch { return null; } })()
      || (typeof Buffer !== 'undefined' ? Buffer.from(data.tx, 'base64') : new Uint8Array());

    // 3) Legacy first; if it throws, try v0
    let tx: Transaction | VersionedTransaction;
    try {
      tx = Transaction.from(bytes);
    } catch {
      tx = VersionedTransaction.deserialize(bytes);
    }

    // 4) Simulate FIRST to get real logs if anything else is wrong
    // @ts-ignore web3 accepts both Transaction and VersionedTransaction
    const sim = await connection.simulateTransaction(tx, { sigVerify: false });
    if (sim.value.err) {
      const logs = (sim.value.logs || []).join('\n');
      throw new Error(`Simulation failed: ${JSON.stringify(sim.value.err)}\n${logs}`);
    }

    // 5) Try provider.signAndSendTransaction (Phantom, etc.)
    const provider: any = (globalThis as any).solana;
    try {
      if (provider?.signAndSendTransaction) {
        const res = await provider.signAndSendTransaction(tx as any);
        const sig = typeof res === 'string' ? res : res?.signature;
        if (!sig) throw new Error('Provider returned no signature');
        setLastSig(sig);
      } else {
        throw new Error('Provider signAndSendTransaction not available');
      }
    } catch (pErr: any) {
      console.warn('provider.signAndSendTransaction failed:', pErr?.message || pErr);

      // 6) Fallback: signTransaction + sendRawTransaction
      if (typeof signTransaction === 'function') {
        const signed = await signTransaction(tx as any);
        const raw = (signed as any).serialize();
        const sig2 = await connection.sendRawTransaction(raw, { skipPreflight: false, maxRetries: 3 });
        setLastSig(sig2);
      } else if (provider?.signTransaction) {
        const signed = await provider.signTransaction(tx as any);
        const raw = (signed as any).serialize();
        const sig2 = await connection.sendRawTransaction(raw, { skipPreflight: false, maxRetries: 3 });
        setLastSig(sig2);
      } else {
        // 7) Last resort: adapter's sendTransaction
        const sig3 = await sendTransaction(tx as any, connection, {
          preflightCommitment: 'processed',
          maxRetries: 3,
          skipPreflight: false,
        });
        setLastSig(sig3);
      }
    }

    // 8) Record trade (best-effort)
    const sig = lastSig;
    fetch(`/api/coins/${encodeURIComponent(coin.id)}/trades`, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({
        ts: new Date().toISOString(),
        amountSol: amount,
        side: 'sell',
        sig,
      }),
    }).catch(() => {});

    alert(`✅ Sold ${amount} SOL\nSignature: ${sig ?? '(pending)'}`);
  } catch (e: any) {
    console.error('Sell error:', e);
    alert(`❌ Sell failed: ${e?.message || String(e)}`);
  } finally {
    setSellBusy(false);
  }
}

  // --- Render guards ---
  if (loading) return <main className="p-6">Loading…</main>;
  if (!coin) return <main className="p-6">Not found.</main>;

  return (
    <main className="max-w-3xl mx-auto p-6 space-y-4">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-semibold">
          {coin.name} <span className="opacity-70">({coin.symbol})</span>
        </h1>
        <WalletMultiButton />
      </div>

      {/* Coin card */}
      <div className="rounded-2xl border p-4 space-y-2">
        <div>
          Curve: <b>{coin.curve}</b> • Start: {coin.startPrice} SOL • Strength:{' '}
          {['Low', 'Medium', 'High'][coin.strength - 1] || coin.strength}
        </div>
        {coin.description && <p className="opacity-90">{coin.description}</p>}
        {coin.logoUrl && (
          <img
            src={coin.logoUrl}
            alt={coin.name}
            className="w-24 h-24 rounded-lg object-cover border"
          />
        )}
        <div className="text-xs opacity-70">
          Created: {new Date(coin.createdAt).toLocaleString()}
        </div>

        {(coin.socials?.x || coin.socials?.website || coin.socials?.telegram) && (
          <div className="mt-3 rounded-xl border p-3 space-y-2">
            <div className="font-medium">Socials</div>
            <div className="flex gap-3 text-sm">
              {coin.socials?.x && (
                <a
                  href={coin.socials.x}
                  target="_blank"
                  rel="noreferrer"
                  className="underline hover:opacity-80"
                >
                  X
                </a>
              )}
              {coin.socials?.website && (
                <a
                  href={coin.socials.website}
                  target="_blank"
                  rel="noreferrer"
                  className="underline hover:opacity-80"
                >
                  Website
                </a>
              )}
              {coin.socials?.telegram && (
                <a
                  href={coin.socials.telegram}
                  target="_blank"
                  rel="noreferrer"
                  className="underline hover:opacity-80"
                >
                  Telegram
                </a>
              )}
            </div>
          </div>
        )}

        {/* Activity sparkline */}
        <div className="mt-3">
          <div className="text-sm opacity-70 mb-1">Activity</div>
          <ActivitySparkline id={coin.id} />
        </div>
      </div>

      {/* BUY */}
      <div className="rounded-2xl border p-4 space-y-3">
        <div className="font-medium">Buy (devnet demo)</div>
        <div className="flex gap-2 mt-2">
          {[0.01, 0.05, 0.1].map((amt) => (
            <button
              key={`buy-${amt}`}
              type="button"
              onClick={() => buy(amt)}
              disabled={!connected || buyBusy}
              className={`px-3 py-1.5 rounded-lg border transition ${
                connected && !buyBusy
                  ? 'hover:bg-white/10 active:scale-[0.99] cursor-pointer'
                  : 'opacity-50 cursor-not-allowed'
              }`}
              title={connected ? `Buy ${amt} SOL worth` : 'Connect wallet to enable'}
            >
              {amt.toFixed(2)} SOL
            </button>
          ))}
        </div>
        <button
          type="button"
          onClick={() => buy(0.01)}
          className="rounded-xl border px-4 py-2"
          disabled={!connected || buyBusy}
        >
          {buyBusy ? 'Buying…' : 'Buy'}
        </button>
      </div>

      {/* SELL */}
      <div className="rounded-2xl border p-4 space-y-3">
        <div className="font-medium">Sell (devnet demo)</div>
        <div className="flex gap-2 mt-2">
          {[0.01, 0.05, 0.1].map((amt) => (
            <button
              key={`sell-${amt}`}
              type="button"
              onClick={() => sell(amt)}
              disabled={!connected || sellBusy}
              className={`px-3 py-1.5 rounded-lg border transition ${
                connected && !sellBusy
                  ? 'hover:bg-white/10 active:scale-[0.99] cursor-pointer'
                  : 'opacity-50 cursor-not-allowed'
              }`}
              title={connected ? `Sell ${amt} SOL worth` : 'Connect wallet to enable'}
            >
              {amt.toFixed(2)} SOL
            </button>
          ))}
        </div>
        <button
          type="button"
          onClick={() => sell(0.01)}
          className="rounded-xl border px-4 py-2"
          disabled={!connected || sellBusy}
        >
          {sellBusy ? 'Selling…' : 'Sell'}
        </button>

        {lastSig && (
          <div className="text-xs opacity-70 break-all">Last tx: {lastSig}</div>
        )}
      </div>
    </main>
  );
}

